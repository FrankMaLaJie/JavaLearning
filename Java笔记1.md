# Java学习笔记1

# 常用DOS命令

|        指令         |                说明                |
| :-----------------: | :--------------------------------: |
|      盘符名称       | 盘符切换。D:→回车，表示切换到D盘。 |
|         dir         |       查看当前路径下的内容。       |
|       cd目录        |       进入单级目录。cd steam       |
|        cd ..        |           返回上级目录。           |
| cd 目录1\目录2\.... |       进入多级目录。cd steam       |
|        cd \         |          返回到盘符目录。          |
|         cls         |               清屏。               |
|        exit         |        退出命令提示符窗口。        |

![image-20200810154333902](C:\Users\Frank\AppData\Roaming\Typora\typora-user-images\image-20200810154333902.png)

!(https://github.com/FrankMaLaJie/JavaLearning/blob/master/image/image-20200810154333902.png?raw=true)



# 关键字

**关键字**：就是被赋予特殊含义的单词。

- 关键字的字母全部都是**小写**。

**输出语句**

```java
System.out.println("内容");//输出内容并且换行
System.out.print("内容");//没有ln的，输出内容不换行
System.out.println();//直接输入这个语句，起到换行的作用
```



## 内置数据类型

**byte：**

- byte 数据类型是8位、有符号的，以二进制补码表示的整数；
- 最小值是 **-128（-2^7）**；
- 最大值是 **127（2^7-1）**；
- 默认值是 **0**；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
- 例子：byte a = 100，byte b = -50。

**short：**

- short 数据类型是 16 位、有符号的以二进制补码表示的整数
- 最小值是 **-32768（-2^15）**；
- 最大值是 **32767（2^15 - 1）**；
- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
- 默认值是 **0**；
- 例子：short s = 1000，short r = -20000。

**int：**

- int 数据类型是32位、有符号的以二进制补码表示的整数；
- 最小值是 **-2,147,483,648（-2^31）**；
- 最大值是 **2,147,483,647（2^31 - 1）**；
- 一般地整型变量默认为 int 类型；
- 默认值是 **0** ；
- 例子：int a = 100000, int b = -200000。

**long：**

- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；
- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；
- 这种类型主要使用在需要比较大整数的系统上；
- 默认值是 **0L**；
- 为了防止整数过大，**long**类型后面要加上**" L "**。
- 例子： long a = 100000L，Long b = -200000L。
  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

**float：**

- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 **0.0f**；
- 浮点数不能用来表示精确的值，如货币；
- 例子：float f1 = 234.5f。
- 为了防止类型不兼容，**float**后面要加上**" F "**。

**double：**

- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；
- 浮点数的默认类型为double类型；
- double类型同样不能表示精确的值，如货币；
- 默认值是 **0.0d**；
- 例子：double d1 = 123.4。

**boolean：**

- boolean数据类型表示一位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 **false**；
- 例子：boolean one = true。

**char：**

- char类型是一个单一的 16 位 Unicode 字符；
- 最小值是 **\u0000**（即为0）；
- 最大值是 **\uffff**（即为65,535）；
- char 数据类型可以储存任何字符；
- 例子：char letter = 'A';。

## 引用数据类型

+ 类（class）
+ 接口（interface）
+ 数组（[ ]）

# 类型转换

**数据类型转换必须满足如下规则：**

1.  不能对boolean类型进行类型转换。

2. 不能把对象类型转换成不相关类的对象。

3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

4. 转换过程中可能导致溢出或损失精度，例如：

   ```java
   int i =128;   
   byte b = (byte)i;
   ```

   因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。

5.  浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如

   ```java
   (int)23.7 == 23;        
   (int)-45.89f == -45
   ```



**自动类型转换**：把一个表示 *<u>数据范围小</u>* 的数值或者变量赋值给另一个表示 <u>*数据范围大*</u> 的变量。

![image-20200810175942765](C:\Users\Frank\AppData\Roaming\Typora\typora-user-images\image-20200810175942765.png)

**强制类型转换**：把一个表示 *<u>数据范围大</u>* 的数值或者变量赋值给另一个表示 <u>*数据范围小*</u> 的变量。

- 条件是转换的数据类型必须是兼容的。
- 格式：目标数据类型 变量名 = （目标数据类型）值或者变量



# 运算符

## 字符“+”的操作

**char字符是可以和整型进行相加。**

+ 字符**‘ A ’**对应整数**65**。（A-Z是连续的）

+ 字符**‘ a ’**对应整数**97**。（a-z是连续的）

+ 字符**‘ 0 ’**对应整数**48**。（0-9是连续的）

算数表达式钟**包含多个基本数据类型**的值时，整个算术表达式的类型会**自动进行提升**。

整个表达式的类型自动提升到表达式中**最高等级操作数**同样的类型。

等级顺序：byte, short, char → int → long → float → double



当 “+” 操作中出现字符串时，这个 ”+“ 是**字符串连接符**，而不是算数运算；

当连续进行 “+” 操作时，从左到右逐个执行，例如：

```java
"马拉杰"+666 == "马拉杰666";
3+3+"马拉杰" == "6马拉杰"
```



## 赋值运算符

以下运算符底层隐含了**强制类型转换**

| 符号 |    作用    |           说明           |
| :--: | :--------: | :----------------------: |
|  =   |    赋值    | a = 10，将10赋值给变量a  |
|  +=  |  加后赋值  |  a += b，将a+b的值赋给a  |
|  -=  |  减后赋值  |  a -= b，将a-b的值赋给a  |
|  *=  |  乘后赋值  | a *= b，将a *b的值赋给a  |
|  /=  |  除后赋值  |  a /= b，将a/b的值赋给a  |
|  %=  | 取余后赋值 | a %= b，将a/b的余数赋给a |

```java
int i = 10;
i += 20; i = i +20; (i = 30)

short s = 10;
s/*(short)*/ = s/*(short)*/ + 20/*(int)*/; (因为数据类型不兼容所以导致报错)

s += 20; s = (short)(s + 20); (s = 30)

```



## 自增自减运算符

- ++ 和 -- 单独使用的时候，结果是一样的。

- 参与操作的时候，放在前面就是，先拿变量做++或者--，后拿变量参与操作。

  参与操作的时候，放在后面就是，先拿变量参与操作，后拿变量做++或者--。**（从左到右）**

  ```java
  int i = 10;
  int j = ++i;(j == 11)//i先做++再赋值
  int k = i++;(k == 10，i == 11)//先赋值，i再++
  ```

## 逻辑运算符

- &无论左边真假，右边都要执行。

  &&如果左边为真，右边执行；**如果左边为假，右边不执行。**

- |无论左边真假，右边都要执行。

  ||如果左边为假，右边执行；**如果左边为真，右边不执行。**

## 三元运算符

- 格式：关系表达式 **？** 表达式1 **：**表达式2。例如：

  a > b ? a ：b

- 计算规则：
  - 先计算关系表达式。
  - 如果为**true**，**表达式1的值**就是运算结果。
  - 如果为**false**，**表达式2的值**就是运算结果。

# 数据输入

### Scanner的使用步骤

1. 导包

2. 创建对象

3. 接受数据

   ```java
   import java.util.Scanner; //导包必须出现在类定义上面
   Scanner sc = new Scanner(System.in); //只有变量sc可以变，其他不能变。
   int i = sc.nextInt(); //只有变量i可以变，其他不能变。
   String s = sc.nextLine();//字符串是nextLine()。
   ```

# 流程控制

**流程控制语句分类**

- 顺序结构
- 分支结构（if， switch）
- 循环结构（for， while， do...while）

当使用switch语句的时候，如果出现**多种情况对应相同结果**，可以使用下面的格式：

```java
switch(month)
{
	case 1:
	case 2:
	case 12:
		System.out.println("冬季")
		break;
}
```

**while 和 do...while 的区别：**

- while 先进行判断再执行。

- do...while 先执行一次后再进行判断。

跳转控制语句：

- continue：用在循环中，基于条件控制，跳过某次循环体内容的执行，继续下一次的执行。
- break：用在循环中，基于条件控制，终止循环体内容的执行，即结束当前整个循环。



# Random

**Random的使用步骤**

1. 导包
2. 创建对象
3. 获取随机数

```java
import java.util.Random; //导包必须出现在类定义上面
Random r = new Random(); //只有变量r可以变，其他不能变。
int number = r.nextInt(10); //变量number，数字10可变，其他不能变。获取范围[0, 10),包括0，不包括10。
```



# 数组

数组是一种用于存储多个相同类型数据的储存模型。

## 初始化方式

- 动态：初始化的时候只指定数组长度，由系统为数组分配初始值。

  - 默认值：

    整数：0

    浮点数：0.0

    布尔值：false

    字符：空字符

    引用数据类型：null

  - 格式：数据类型 [ ] 变量名 = new 数据类型 [ 数组长度 ]，例如

    ```java
    int [] arr = new int [3];
    /*
    左边:
    	int：数组中元素类型是int
    	[]:说明这是一个数组
    	arr：数组名称
    右边：
    	new：为数组申请内存空间
    	int：数组中元素类型是int
    	[]:说明这是一个数组
    	3：数组长度，即数组中元素的个数
    */
    ```

- 静态：初始化的时候指定每个数组元素的初始值，由系统决定数组长度。

  - 格式：数据类型 [ ] 变量名 = new 数据类型 [ ]{数据1，数据2，数据3，数据4，....};

    ​			数据类型 [ ] 变量名 = {数据1，数据2，数据3，数据4，....};

  ```java
  int[] arr = new int[]{1,2,3};
  int[] arr = {1,2,3};
  ```



## 数组元素访问

- 数组变量方位方式：数组名。
- 数组内部保存的数据的访问方式：数组名[索引]。
- 索引是数组中数据的编号方式，用于访问数组中的数据使用。
  - 索引从0开始。
  - 索引连续。
  - 索引逐一增加1。
- 直接输出数组名就会输出数组的**地址**。



## 内存分配

为了提高效率，对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。

![image-20200812171801822](C:\Users\Frank\AppData\Roaming\Typora\typora-user-images\image-20200812171801822.png)

图中 **arr** 指向 **001** 这一片内存空间，**001** 赋值给了 **arr** 。

![image-20200812172158905](C:\Users\Frank\AppData\Roaming\Typora\typora-user-images\image-20200812172158905.png)

**arr[0]** 中的 **0** 找到内存 **001** 中的 **0**，然后输出所对应的数值。

- 栈内存（红色）：存储局部变量，使用完毕后立刻消失。
- 堆内存（蓝色）：存储new出来的内容（实体，对象），每一个new出来的东西都有一个地址值，使用完毕后会在垃圾回收器空闲时被回收。



## 多个数组指向相同

当两个数组指向相同的时候，任意一个数组修改堆内存的数据，另一个数组访问时，对应的元素值也会发生改变。

```java
int[] arr = new int[3];
arr[0] = 100;
arr[1] = 200;
arr[2] = 300;

int[] arr2 = arr;//arr的值（数组的地址001）赋给arr2,arr和arr2指向同一个数组
arr2[0] = 111;
arr2[1] = 222;
arr2[2] = 333;
```

![image-20200813222826226](C:\Users\Frank\AppData\Roaming\Typora\typora-user-images\image-20200813222826226.png)

![image-20200813223001860](C:\Users\Frank\AppData\Roaming\Typora\typora-user-images\image-20200813223001860.png)



## 数组操作的两个常见小问题

- 索引越界：访问了数组中不存在的索引对应的元素，造成索引越界。
- 空指针异常：访问的数组已经不再指向堆内存的数据，造成空指针异常。

```java
int[] arr = new int[3];
System.out.println(arr[3]);//不存在，报错。
arr = null;//arr不再指向之前的数组。
System.out.println(arr[0]);//arr不再指向对应数组，无法访问，报错。
```



## 数组的操作

### 遍历

获取数组元素个数

- 格式：数组名.length，例如：arr.length

```java
int[] arr = {...};
//遍历通用格式
for(int i = 0; i < arr.length; i++)
{
    System.out.println(arr[i]);
}
```



### 获取最值

```java
int[] arr = {12, 45, 98, 73, 60};
//定义一个变量用于保存最大值（最小值）,取数组中第一个数据作为初始值。
int max = arr[0];
//用这个值和数组中的数据逐个作比较，将每次对比中，更大的值保存到变量中。
for(int i = 1; i < arr.length; i++)
{
    if(arr[i] > max)
    {
        max = arr[i];
    }
}
//输出
System.out.println(max);
```



# 方法

将具有独立功能的**代码块**组织成一个整体，使其具有特殊功能的代码集。

**形参：**方法**定义中**的参数，等同于变量定义格式。

**实参：**方法**调用中**的参数，等同于使用变量或者常量。

- 必须先创建才可以使用（定义）。
- 创建后需要手动使用才可以执行（方法调用）。

```java
public static void main(String[] args) 
    {
        方法名(参数1,...);//方法调用
    }

    public static 返回值类型 方法名(参数1,....)//方法定义
    {
        //方法体
        return 与返回值类型对应的数据;
    }
```

- 方法定义时，若有返回值，最后**return**后面的返回值与方法定义上的数据类型要匹配。
- 方法调用时，参数的数量和类型必须和方法定义中的设置完全匹配。
- 有返回类型的方法推荐用变量接收调用（Ctrl + Alt + v）。



## 方法重载

同一个类中定义的多个方法之间的关系，满足以下条件的多个方法相互构成重载。

1. 多个方法再同一个类中。
2. 多个方法具有相同的方法名。
3. 多个方法的参数不同，类型不同或者数量不同。

**特点**

- 重载仅仅对应方法的**定义**，和方法的调用无关，调用方式参照标准格式。
- 重载仅仅针对同一个类中方法的名称和参数进行识别，和返回值无关（不能通过返回值来判定两个方法是否构成重载）。
- Java虚拟机会通过参数的不同来区分同名的方法。

```java
//1
public class MethodDemo
{
    public static void fn(int a){}//不是重载，因为方法名和参数都相同。
    public static int fn(int a){}
}
//2
public class MethodDemo
{
    public static float fn(int a){}//是重载，因为方法名相同，但参数不同。
    public static int fn(int a, int b){}
}
//3
public class MethodDemo
{
    public static float fn(int a){}//是重载，因为方法名相同，但参数不同。
    public static int fn(double a){}
}
//4
public class MethodDemo01
{
    public static void fn(int a){}//不是重载，因为不在同一个类中。
}
public class MethodDemo02
{
    public static int fn(double a){}
}
```



## 方法参数传递

### 基本类型

对于基本数据类型的参数，形式参数的改变，**不影响**实际参数的值。

![image-20200813235951250](C:\Users\Frank\AppData\Roaming\Typora\typora-user-images\image-20200813235951250.png)

```java
public static void main(String[] args){
    int num = 100;
    System.out.println(num);//输出100
    change(num);//此时change中num是200，但修改完数据后，change弹出栈消除
    System.out.println(num);//此时main中的参数num的值依然是100，输出还是100
}
public static void change(int x){
    x = 200;
}
```

### 引用类型

对于引用数据类型的参数，形式参数的改变，**影响**实际参数的值。

```java
public static void main(String[] args){
    int[] arr = {1, 2, 3};
    System.out.println(arr[0]);//输出1
    change(arr);//此时修改了 “堆内存” 中的数据
    System.out.println(arr[0]);//因为“堆内存”的值已被改变，所以输出是已改变的值200
}
public static void change(int[] arr){
    arr[0] = 200;
}
```



